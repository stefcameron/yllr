{"version":3,"sources":["yllr.js"],"names":["global","factory","libName","define","amd","module","exports","prevValue","lib","config","noConflict","undefined","this","$yllr","DEFAULT_MESSAGE","TYPE_EMPTY","YllrError","SuperCtr","Error","message","context","call","name","prototype","Object","create","constructor","toString","__ErrorType","__checksEnabled","tokenize","tokens","forEach","token","i","replace","RegExp","__onFail","onFail","__check","condition","params","result","slice","arguments","length","check","apply","make","proto","setErrorType","ErrorType","enableChecks","enable","checksEnabled"],"mappings":";;;;CAIA,SAAUA,EAAQC,GAChB,YAEA,IAAIC,GAAU,MAEQ,mBAAXC,SAAyBA,OAAOC,IACzCD,OAAOD,KAAaD,GACO,gBAAXI,SAAiD,gBAAnBA,QAAOC,QACrDD,OAAOC,QAAUL,KAGjB,SAAUM,GACR,GAAIC,GAAMP,GAEVD,GAAOE,GAAWM,EAgBlBA,EAAIC,OAAOC,WAAa,WAGtB,MAFAV,GAAOE,GAAWK,EAClBC,EAAIC,OAAOC,WAAaC,OACjBH,IAERR,EAAOE,KAEXU,KAAM,WACP,YAIA,IASIC,GATAC,EAAkB,oBAIlBC,EAAa,UAQbC,EAAY,WACd,GAAIC,GAAWC,MAcXF,EAAY,SAASG,EAASC,GAChCH,EAASI,KAAKT,MAOdA,KAAKO,QAAUA,EAOfP,KAAKU,KAAO,YAOZV,KAAKQ,QAAUA,EAmBjB,OAhBAJ,GAAUO,UAAYC,OAAOC,OAAOR,EAASM,WAC7CP,EAAUO,UAAUG,YAAcV,EAQlCA,EAAUO,UAAUI,SAAW,WAE7B,MAAOf,MAAKU,KAAO,MACGX,SAAjBC,KAAKQ,QAAyBR,KAAKQ,QAAU,KAAQ,IACtDR,KAAKO,SAGJH,KAMLY,EAAcZ,EAKda,GAAkB,EAelBC,EAAW,SAASX,EAASY,EAAQX,GAavC,MAZAD,GAAUA,GAAW,GACrBY,EAASA,MAMTA,EAAOC,QAAQ,SAASC,EAAOC,GAC7Bf,EAAUA,EAAQgB,QAAQ,GAAIC,QAAO,MAAQF,EAAI,MAAO,KACpD,IAAgB,KAAVD,EAAelB,EAAakB,MAGjCd,GAQLkB,EAAW,SAASlB,EAASY,GAC/B,GAAIX,GAAUR,OAASC,EAAQF,OAAYC,KAAKQ,OAOhD,MAFAD,GAAUN,EAAMiB,SAASX,GAAWL,EAAiBiB,EAAQX,GAEvD,GAAIQ,GAAYT,EAASC,IAiD7BkB,EAAS,SAASnB,EAASY,GAC7BM,EAAShB,KAAKT,KAAMO,EAASY,IAa3BQ,EAAU,SAASC,EAAWrB,GAChC,GAAIsB,GACAV,EACAW,CAEAb,KACFa,EAA+B,kBAAdF,GAA4BA,IAAcA,EAEtDE,IACHD,KAAYE,MAAMtB,KAAKuB,WAKnBb,EAHkB,IAAlBU,EAAOI,OACyC,mBAA9CrB,OAAOD,UAAUI,SAASN,KAAKoB,EAAO,IAE/BA,EAAO,IAGNA,EAAO,IAEVA,EAAOI,OAAS,EAEhBJ,EAAOE,MAAM,MAOxB/B,KAAK0B,OAAOnB,EAASY,MAiCvBe,EAAQ,SAASN,EAAWrB,GAE9BoB,EAAQQ,MAAMnC,QAAS+B,MAAMtB,KAAKuB,aAUhCI,EAAO,SAAS5B,GAClB,GAAI6B,EAqDJ,OAnDA7B,GAAsBT,SAAZS,EAAwB,KAAOA,EASzC6B,GAQE7B,QAASA,EAUT0B,MAAO,SAASN,EAAWrB,GAGzBoB,EAAQQ,MAAMnC,QAAS+B,MAAMtB,KAAKuB,aAcpCN,OAAQ,SAASnB,EAASY,GAGxBM,EAASU,MAAMnC,QAAS+B,MAAMtB,KAAKuB,cAIhCpB,OAAOC,OAAOwB,IAWnBC,EAAe,SAASC,GAC1BvB,EAAoC,kBAAduB,GAA4BA,EAAYnC,GAW5DoC,EAAe,SAASC,GAC1BxB,EAA6BlB,SAAX0C,KAA0BA,GAS1CC,EAAgB,WAClB,MAAOzB,GAkCT,OA3BAhB,IAEEG,UAAWA,EAGXc,SAAUA,EACVgB,MAAOA,EACPE,KAAMA,EAGNV,OAAQA,EAMR7B,QAEEyC,aAAcA,EACdE,aAAcA,EACdE,cAAeA,EAGf5C,WAAYC","file":"yllr.min.js","sourcesContent":["/*!\n * yllr 1.0.0\n * @license MIT, https://github.com/stefcameron/yllr/blob/master/LICENSE\n */\n(function(global, factory) {\n  'use strict';\n\n  var libName = 'yllr';\n\n  if (typeof define === 'function' && define.amd) {\n    define(libName, [], factory); // AMD\n  } else if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory(); // CommonJS\n  } else {\n    // Global\n    (function(prevValue) {\n      var lib = factory();\n\n      global[libName] = lib;\n\n      /**\n       * Restores the previous value of `global.yllr` (i.e. `window.yllr`) and\n       *  returns a reference to the `yllr` library.\n       *\n       * This configuration function only exists if the library was registered\n       *  into the global namespace. It will not exist if it was registered as\n       *  an AMD or CommonJS module.\n       *\n       * Once this function is called, it will be removed (i.e. it can only be\n       *  called once).\n       *\n       * @function yllr.config.noConflict\n       * @returns {yllr} Reference to the `yllr` library.\n       */\n      lib.config.noConflict = function() {\n        global[libName] = prevValue; // restore previous value (even if `undefined`)\n        lib.config.noConflict = undefined; // remove this function\n        return lib; // return the library\n      };\n    })(global[libName]);\n  }\n})(this, function() {\n  'use strict';\n\n  // Default message to display if one isn't provided for a `check()`.\n  // @const {String}\n  var DEFAULT_MESSAGE = 'runtime assertion';\n\n  // Representation of an empty string passed as a token in `check()`.\n  // @const {String}\n  var TYPE_EMPTY = '<empty>';\n\n  // Global `yllr` library definition.\n  // @type {Object}\n  // @see yllr\n  var $yllr;\n\n  // @type {Function}\n  var YllrError = (function() {\n    var SuperCtr = Error;\n\n    /**\n     * [[extends: `JavaScript.Error`]]\n     * Defines the error that is thrown by default when a check fails.\n     *  `error.name` is set to `YllrError`.\n     * @class yllr.YllrError\n     * @param {String} message The error message.\n     * @param {(Object|undefined)} [context] Optional context object to associate\n     *  with the error. An `undefined` value equates to no context. If this error\n     *  is being instantiated from a _contextual yllr object_, this parameter should\n     *  be the associated context.\n     * @see {@link yllr.make `yllr.make`}\n     */\n    var YllrError = function(message, context) {\n      SuperCtr.call(this);\n\n      /**\n       * Error message.\n       * @name yllr.YllrError#message\n       * @type {String}\n       */\n      this.message = message;\n\n      /**\n       * Error name/code.\n       * @name yllr.YllrError#name\n       * @type {String}\n       */\n      this.name = 'YllrError';\n\n      /**\n       * Error context, if specified; `undefined` if there is no context.\n       * @name yllr.YllrError#context\n       * @type {(Object|undefined)}\n       */\n      this.context = context;\n    };\n\n    YllrError.prototype = Object.create(SuperCtr.prototype);\n    YllrError.prototype.constructor = YllrError;\n\n    /**\n     * [[overrides: `JavaScript.Error.toString()`]]\n     * Generates a string representation of this error.\n     * @method yllr.YllrError#toString\n     * @returns {String} A string representation of this error.\n     */\n    YllrError.prototype.toString = function() {\n      // use a format similar to Error.toString()\n      return this.name + ': ' +\n          (this.context !== undefined ? (this.context + ': ') : '') +\n          this.message;\n    };\n\n    return YllrError;\n  })();\n\n  // Type of error to throw when a check fails. Defaults to `yllr.YllrError`.\n  // @type {Function}\n  // @see #setErrorType()\n  var __ErrorType = YllrError;\n\n  // `true` if failed checks should result in failures; `false` if checks should\n  //  be ignored.\n  // @type\n  var __checksEnabled = true;\n\n  /**\n   * Replace any tokens in a given message.\n   * @function yllr.tokenize\n   * @param {String} message Message containing `{n}`-style tokens. If _falsy_,\n   *  it's considered to be an empty strig.\n   * @param {Array} tokens Token values. Any tokens which aren't strings are\n   *  cast to strings.\n   * @param {(Object|undefined)} [context] Optional context associated with the\n   *  `message`. An `undefined` value equates to no context. __Note:__ the current\n   *  implementation ignores this parameter.\n   * @returns {String} Message with tokens substituted; empty string if `message`\n   *  was _falsy_.\n   */\n  var tokenize = function(message, tokens, context) {\n    message = message || ''; // normalize\n    tokens = tokens || []; // normalize\n\n    // NOTE: `context` is ignored since we're replacing any tokens; it's passed\n    //  in just in case someone decides they want to override this method and\n    //  for some reason want the `context`\n\n    tokens.forEach(function(token, i) {\n      message = message.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'),\n          '' + (token === '' ? TYPE_EMPTY : token));\n    });\n\n    return message;\n  };\n\n  // Internal failure handler. Called within the context of the related `yllr`:\n  //  Either the `yllr` library, or a contextual `yllr` object.\n  // @param {String} message See `yllr.onFail@message`.\n  // @param {Array} tokens See `yllr.onFail@tokens`.\n  // @see yllr.onFail\n  var __onFail = function(message, tokens) {\n    var context = this === $yllr ? undefined : this.context;\n\n    // call global/public `tokenize()` in its normal execution context since it's\n    //  not meant to be a 'method' of the `yllr` library nor a contextual `yllr`\n    //  object\n    message = $yllr.tokenize(message || DEFAULT_MESSAGE, tokens, context);\n\n    throw new __ErrorType(message, context);\n  };\n\n  /**\n   * Handle a failed check. The default behavior is to throw a new instance\n   *  of the {@link yllr.config.setErrorType configured error type}.\n   *\n   * Override this method to customize the behavior of a failed check:\n   *\n   * ```javascript\n   * //// Global checks:\n   * yllr.onFail = function(message, tokens) {\n   *   // custom code...\n   * };\n   * ```\n   *\n   * ```javascript\n   * //// Contextual checks (per-instance):\n   * var y = yllr.make('myFunction');\n   * y.onFail = function(message, tokens) {\n   *   // custom code...\n   * };\n   * ```\n   *\n   * ```javascript\n   * //// Contextual checks (all instances):\n   * (function(yllrMake) {\n   *   var ctxOnFail = function(message, tokens) {\n   *     // custom code...\n   *   };\n   *   yllr.make = function(context) {\n   *     var y = yllrMake.call(this, context);\n   *     y.onFail = ctxOnFail;\n   *     return y;\n   *   };\n   * })(yllr.make);\n   * ```\n   *\n   * @function yllr.onFail\n   * @param {(String|undefined)} message Failed check message (may contain tokens).\n   *  If _falsy_ (because a message wasn't provided for the failed check), a default\n   *  message is used. The {@link yllr.tokenize} function is used to substitute any\n   *  tokens into the `message`.\n   * @param {Array} tokens Token values to substitute into `message`. Empty\n   *  array if none were given for the failed check.\n   * @see {@link yllr.check `yllr.check()`}\n   * @see {@link yllr.Yllr#check `yllr.Yllr#check()`}\n   * @see {@link yllr.Yllr#onFail `yllr.Yllr#onFail()`}\n   */\n  var onFail = function(message, tokens) {\n    __onFail.call(this, message, tokens);\n  };\n\n  // Internal check function. Called within the execution context of the related\n  //  `yllr`: Either the global `yllr`, or a contextual `yllr` object.\n  // @param {*} condition See `yllr.check@condition`.\n  // @param {String} [message] See `yllr.check@message`.\n  // @param {Array.<String>|...} [tokens] Optional substitution tokens for the\n  //  `message`. Either an array of strings, or multiple string parameters.\n  //  If a 4th parameter is specified and is an array, only that parameter is\n  //  is used (considered to be __all__ tokens). Otherwise, all remaining parameters\n  //  are used as the combined list of tokens.\n  // @see yllr.check\n  var __check = function(condition, message) {\n    var params; // {Array.<Object>}\n    var tokens; // {Array.<Object>} (should be strings)\n    var result; // {*} truthy/falsy value\n\n    if (__checksEnabled) {\n      result = (typeof condition === 'function') ? condition() : condition;\n\n      if (!result) {\n        params = [].slice.call(arguments);\n\n        if (params.length === 3) {\n          if (Object.prototype.toString.call(params[2]) === '[object Array]') {\n            // token array specified\n            tokens = params[2];\n          } else {\n            // some other type: consider it a single token and wrap in array\n            tokens = [params[2]];\n          }\n        } else if (params.length > 3) {\n          // list of tokens: get an array with all of them\n          tokens = params.slice(2);\n        } else {\n          // no tokens\n          tokens = [];\n        }\n\n        // call the failure hanler within the current execution context\n        this.onFail(message, tokens);\n      }\n    }\n  };\n\n  /**\n   * Check a condition.\n   * @function yllr.check\n   * @param {*} condition Condition to check. If _truthy_, the check passes and\n   *  nothing happens. If _falsy_, the check fails, causing a new error to be\n   *  thrown with the specified message.\n   *\n   *  If the `condition` is a function, it's expected to be one which returns\n   *  a _truthy_ or _falsy_ value. Using a function ensures that the condition\n   *  evaluation code is truly only executed IIF checks are enabled.\n   *\n   * @param {String} [message] Optional message. A generic message is used if\n   *  one is not provided.\n   * @param {...String} [tokens] Optional substitution tokens for the\n   *  `message`, passed to the generated error. This can be specified either as\n   *  a _single_ `Array.<String>` parameter (in which case each element is considered\n   *  to be a token), or as multiple parameters (in which case arrays are treated\n   *  as tokens, not their elements).\n   *\n   *  When using the single array parameter, an array can be passed as a single\n   *   token by wrapping it in the token array: `[[1, 2, 3], 'a']` would result\n   *   in two tokens, the first being an `Array.<Number>` and the second being\n   *   a `String`. This is the exception if you need to pass one token and it\n   *   happens to be an array.\n   *\n   * @see {@link yllr.make `yllr.make`}\n   * @see {@link yllr.config.enableChecks `yllr.config.enableChecks`}\n   */\n  var check = function(condition, message) {\n    // invoke internal `__check()` within the current execution context\n    __check.apply(this, [].slice.call(arguments));\n  };\n\n  /**\n   * Make a new contextual `yllr` object. The `context` is passed to the\n   *  {@link yllr.config.setErrorType error type} constructor when a check fails.\n   * @function yllr.make\n   * @param {Object} context Associated context. Can be any value except `undefined`;\n   *  normally a `String`. If `undefined`, will be interpreted as `null`.\n   */\n  var make = function(context) {\n    var proto;\n\n    context = context === undefined ? null : context;\n\n    /**\n     * Contextual yllr object. It has the same interface as the library's main\n     *  functions (with the exception of {@link yllr.make `yllr.make`}), with the\n     *  addition of an associated context to help with debugging (for instance,\n     *  to make it easier to identify the source of the failure).\n     * @class yllr.Yllr\n     */\n    proto = {\n      /**\n       * The context associated with this `yllr` object. Note that `null` is\n       *  technically an object and therefore a valid context. This property\n       *  should not be `undefined` given how {@link yllr.make `yllr.make()`} works.\n       * @name yllr.Yllr#context\n       * @type {Object}\n       */\n      context: context,\n\n      /**\n       * Perform a contextual condition check.\n       * @method yllr.Yllr#check\n       * @param {*} condition Condition to check.\n       * @param {String} [message] Optional message.\n       * @param {...String} [tokens] Optional substitution tokens.\n       * @see {@link yllr.check `yllr.check`}\n       */\n      check: function(condition, message) {\n        // invoke internal `__check()` within the current execution context using\n        //  any/all given parameters\n        __check.apply(this, [].slice.call(arguments));\n      },\n\n      /**\n       * Handle a contextual check failure.\n       *\n       * Override this method to customize the behavior of a failed contextual\n       *  check.\n       *\n       * @method yllr.Yllr#onFail\n       * @param {(String|undefined)} message Associated message, if any.\n       * @param {Array} tokens Tokens, if any; empty if none.\n       * @see {@link yllr.onFail `yllr.onFail`}\n       */\n      onFail: function(message, tokens) {\n        // invoke internal `__onFail()` within the current execution context using\n        //  any/all given parameters\n        __onFail.apply(this, [].slice.call(arguments));\n      }\n    };\n\n    return Object.create(proto);\n  };\n\n  /**\n   * Customizes the type of error thrown when a `check` fails.\n   * @function yllr.config.setErrorType\n   * @param {Function} [ErrorType] If specified, expected to be a constructor\n   *  function which has the same signature as the default `YllrError`. If\n   *  not a function, resets the error type to `YllrError`.\n   * @see {@link yllr.YllrError `yllr.YllrError`}\n   */\n  var setErrorType = function(ErrorType) {\n    __ErrorType = (typeof ErrorType === 'function') ? ErrorType : YllrError;\n  };\n\n  /**\n   * Allows enabling or disabling all checks. Subsequent calls to `yllr.check`\n   *  will cause failures if enabled, or do nothing if disabled.\n   * @function yllr.config.enableChecks\n   * @param {Boolean} [enable=true] If _truthy_ (or unspecified), checks are\n   *  enabled; otherwise, checks are disabled.\n   * @see {@link yllr.config.checksEnabled `yllr.config.checksEnabled()`}\n   */\n  var enableChecks = function(enable) {\n    __checksEnabled = enable === undefined || !!enable;\n  };\n\n  /**\n   * Determines if all checks are enabled; a compliment to `config.enableChecks()`.\n   * @function yllr.config.checksEnabled\n   * @returns {Boolean} `true` if all checks are enabled; `false` otherwise.\n   * @see {@link yllr.config.enableChecks `yllr.config.enableChecks()`}\n   */\n  var checksEnabled = function() {\n    return __checksEnabled;\n  };\n\n  /**\n   * The `yllr` library.\n   * @namespace yllr\n   */\n  $yllr = {\n    // types\n    YllrError: YllrError,\n\n    // functions\n    tokenize: tokenize,\n    check: check,\n    make: make,\n\n    // handlers\n    onFail: onFail,\n\n    /**\n     * Configuration options.\n     * @namespace yllr.config\n     */\n    config: {\n      // functions\n      setErrorType: setErrorType,\n      enableChecks: enableChecks,\n      checksEnabled: checksEnabled,\n\n      // NOTE: noConflict is set by the UMD only when registering as a global\n      noConflict: undefined\n    }\n  };\n\n  return $yllr;\n});\n"]}