{"version":3,"file":"yllr.min.js","sources":["yllr.js"],"names":["global","factory","libName","define","amd","module","exports","prevValue","lib","config","noConflict","undefined","this","DEFAULT_MESSAGE","TYPE_EMPTY","YllrError","SuperCtr","Error","message","tokens","context","call","name","forEach","token","i","replace","bind","prototype","Object","create","constructor","toString","__ErrorType","__checksEnabled","__check","condition","params","result","slice","arguments","length","check","apply","concat","Array","make","proto","setErrorType","ErrorType","enableChecks","enable","checksEnabled"],"mappings":";;;;CAIA,SAAUA,EAAQC,GAChB,YAEA,IAAIC,GAAU,MAEQ,mBAAXC,SAAyBA,OAAOC,IACzCD,OAAOD,KAAaD,GACO,gBAAXI,SAAiD,gBAAnBA,QAAOC,QACrDD,OAAOC,QAAUL,KAGjB,SAAUM,GACR,GAAIC,GAAMP,GAEVD,GAAOE,GAAWM,EAgBlBA,EAAIC,OAAOC,WAAa,WAGtB,MAFAV,GAAOE,GAAWK,EAClBC,EAAIC,OAAOC,WAAaC,OACjBH,IAERR,EAAOE,KAEXU,KAAM,WACP,YAIA,IAAIC,GAAkB,oBAIlBC,EAAa,UAGbC,EAAY,WACd,GAAIC,GAAWC,MAkBXF,EAAY,SAASG,EAASC,EAAQC,GACxCJ,EAASK,KAAKT,MAOdA,KAAKM,QAAUA,EAOfN,KAAKU,KAAO,YAOZV,KAAKQ,QAAUA,GAAWT,OAE1BQ,EAASA,MACTA,EAAOI,QAAQ,SAASC,EAAOC,GAC7Bb,KAAKM,QAAUN,KAAKM,QAAQQ,QAAQ,IAAMD,EAAI,IAAK,IACpC,KAAVD,EAAeV,EAAaU,KACjCG,KAAKf,OAkBT,OAfAG,GAAUa,UAAYC,OAAOC,OAAOd,EAASY,WAC7Cb,EAAUa,UAAUG,YAAchB,EAQlCA,EAAUa,UAAUI,SAAW,WAE7B,MAAOpB,MAAKU,KAAO,MAAQV,KAAKQ,QAAWR,KAAKQ,QAAU,KAAQ,IAC9DR,KAAKM,SAGJH,KAMLkB,EAAclB,EAKdmB,GAAkB,EAMlBC,EAAU,SAASf,EAASgB,EAAWlB,GACzC,GAAImB,GACAlB,EACAmB,CAEJ,IAAIJ,IACFI,EAA+B,kBAAdF,GAA4BA,IAAcA,GACtDE,GAaH,KAZAD,MAAYE,MAAMlB,KAAKmB,WACD,IAAlBH,EAAOI,OAEPtB,EADgD,mBAA9CU,OAAOD,UAAUI,SAASX,KAAKgB,EAAO,IAC/BA,EAAO,IAENA,EAAO,IAEVA,EAAOI,OAAS,IAEzBtB,EAASkB,EAAOE,MAAM,IAGlB,GAAIN,GAAYf,GAAWL,EAAiBM,EAAQC,IAiC5DsB,EAAQ,SAASN,EAAWlB,GAE9BiB,EAAQQ,MAAM/B,MAAOD,QAAWiC,OAAOC,MAAMjB,UAAUW,MAAMlB,KAAKmB,cAShEM,EAAO,SAAS1B,GAClB,GAAI2B,EA0BJ,OAxBAL,GAAMtB,GAA8B,gBAAZA,GACpB,qCASJ2B,GAQEL,MAAO,SAASN,EAAWlB,GAEzBiB,EAAQQ,MAAM/B,MAAOQ,GAASwB,OAAOC,MAAMjB,UAAUW,MAAMlB,KAAKmB,eAI7DX,OAAOC,OAAOiB,IAWnBC,EAAe,SAASC,GAC1BP,GAAOO,GAAkC,kBAAdA,GACvB,wCAEJhB,EAAgBgB,EAAYA,EAAYlC,GAWtCmC,EAAe,SAASC,GAC1BjB,EAA6BvB,SAAXwC,KAA0BA,GAS1CC,EAAgB,WAClB,MAAOlB,GAOT,QAEEnB,UAAWA,EAGX2B,MAAOA,EACPI,KAAMA,EAMNrC,QAEEuC,aAAcA,EACdE,aAAcA,EACdE,cAAeA,EAGf1C,WAAYC","sourcesContent":["/*!\n * yllr 0.0.5\n * @license MIT, https://github.com/stefcameron/yllr/blob/master/LICENSE\n */\n(function(global, factory) {\n  'use strict';\n\n  var libName = 'yllr';\n\n  if (typeof define === 'function' && define.amd) {\n    define(libName, [], factory); // AMD\n  } else if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory(); // CommonJS\n  } else {\n    // Global\n    (function(prevValue) {\n      var lib = factory();\n\n      global[libName] = lib;\n\n      /**\n       * Restores the previous value of `global.yllr` (i.e. `window.yllr`) and\n       *  returns a reference to the `yllr` library.\n       *\n       * This configuration function only exists if the library was registered\n       *  into the global namespace. It will not exist if it was registered as\n       *  an AMD or CommonJS module.\n       *\n       * Once this function is called, it will be removed (i.e. it can only be\n       *  called once).\n       *\n       * @function yllr.config.noConflict\n       * @returns {yllr} Reference to the `yllr` library.\n       */\n      lib.config.noConflict = function() {\n        global[libName] = prevValue; // restore previous value (even if `undefined`)\n        lib.config.noConflict = undefined; // remove this function\n        return lib; // return the library\n      };\n    })(global[libName]);\n  }\n})(this, function() {\n  'use strict';\n\n  // Default message to display if one isn't provided for a `check()`.\n  // @type {String}\n  var DEFAULT_MESSAGE = 'runtime assertion';\n\n  // Representation of an empty string passed as a token in `check()`.\n  // @type {String}\n  var TYPE_EMPTY = '<empty>';\n\n  // @type {Function}\n  var YllrError = (function() {\n    var SuperCtr = Error;\n\n    /**\n     * [[extends: `JavaScript.Error`]]\n     * Defines the error that is thrown by default when a check fails.\n     *  `error.name` is set to `YllrError`.\n     * @class yllr.YllrError\n     * @param {String} message The error message.\n     * @param {Array.<String>} [tokens] Optional tokens to substitute into the\n     *  `message` specified. If tokens are provided, `message` is expected to\n     *  contain substitution tokens using the `{n}` syntax where `n` is a zero-based\n     *  index matching a token string found in `tokens`.\n     * @param {String} [context] Optional context string to associate with the error.\n     *  A _falsy_ value will be considered `undefined` (no context). If this error\n     *  is being instantiated from a _contextual yllr object_, this parameter\n     *  will be the associated context.\n     * @see {@link yllr.make `yllr.make`}\n     */\n    var YllrError = function(message, tokens, context) {\n      SuperCtr.call(this);\n\n      /**\n       * Error message.\n       * @name yllr.YllrError#message\n       * @type {String}\n       */\n      this.message = message;\n\n      /**\n       * Error name/code.\n       * @name yllr.YllrError#name\n       * @type {String}\n       */\n      this.name = 'YllrError';\n\n      /**\n       * Error context, if specified; `undefined` otherwise.\n       * @name yllr.YllrError#context\n       * @type {(String|undefined)}\n       */\n      this.context = context || undefined;\n\n      tokens = tokens || []; // normalize\n      tokens.forEach(function(token, i) {\n        this.message = this.message.replace('{' + i + '}', '' +\n            (token === '' ? TYPE_EMPTY : token));\n      }.bind(this));\n    };\n\n    YllrError.prototype = Object.create(SuperCtr.prototype);\n    YllrError.prototype.constructor = YllrError;\n\n    /**\n     * [[overrides: `JavaScript.Error.toString()`]]\n     * Generates a string representation of this error.\n     * @method yllr.YllrError#toString\n     * @returns {String} A string representation of this error.\n     */\n    YllrError.prototype.toString = function() {\n      // use a format similar to Error.toString()\n      return this.name + ': ' + (this.context ? (this.context + ': ') : '') +\n          this.message;\n    };\n\n    return YllrError;\n  })();\n\n  // Type of error to throw when a check fails. Defaults to `yllr.YllrError`.\n  // @type {Function}\n  // @see #setErrorType()\n  var __ErrorType = YllrError;\n\n  // `true` if failed checks should result in failures; `false` if checks should\n  //  be ignored.\n  // @type\n  var __checksEnabled = true;\n\n  // Internal check function.\n  // @param {String} context Context to associate with the thrown error. Can be\n  //  omitted with a falsy value.\n  // @see yllr.check\n  var __check = function(context, condition, message) {\n    var params; // {Array.<Object>}\n    var tokens; // {Array.<Object>} (should be strings)\n    var result; // {*} truthy/falsy value\n\n    if (__checksEnabled) {\n      result = (typeof condition === 'function') ? condition() : condition;\n      if (!result) {\n        params = [].slice.call(arguments);\n        if (params.length === 4) {\n          if (Object.prototype.toString.call(params[3]) === '[object Array]') {\n            tokens = params[3]; // token array specified\n          } else {\n            tokens = [params[3]]; // some other type: consider it a token\n          }\n        } else if (params.length > 4) {\n          // list of tokens\n          tokens = params.slice(3);\n        }\n\n        throw new __ErrorType(message || DEFAULT_MESSAGE, tokens, context);\n      }\n    }\n  };\n\n  /**\n   * Check a condition.\n   * @function yllr.check\n   * @param {*} condition Condition to check. If _truthy_, the check passes and\n   *  nothing happens. If _falsy_, the check fails, causing a new error to be\n   *  thrown with the specified message.\n   *\n   *  If the `condition` is a function, it's expected to be one which returns\n   *  a _truthy_ or _falsy_ value. Using a function ensures that the condition\n   *  evaluation code is truly only executed IIF checks are enabled.\n   *\n   * @param {String} [message] Optional message. A generic message is used if\n   *  one is not provided.\n   * @param {...String} [tokens] Optional substitution tokens for the\n   *  `message`, passed to the generated error. This can be specified either as\n   *  a _single_ `Array.<String>` parameter (in which case each element is considered\n   *  to be a token), or as multiple parameters (in which case arrays are treated\n   *  as tokens, not their elements).\n   *\n   *  When using the single array parameter, an array can be passed as a single\n   *   token by wrapping it in the token array: `[[1, 2, 3], 'a']` would result\n   *   in two tokens, the first being an `Array.<Number>` and the second being\n   *   a `String`. This is the exception if you need to pass one token and it\n   *   happens to be an array.\n   *\n   * @see {@link yllr.make `yllr.make`}\n   * @see {@link yllr.config.enableChecks `yllr.config.enableChecks`}\n   */\n  var check = function(condition, message) {\n    // invoke internal `__check()` without a context\n    __check.apply(this, [undefined].concat(Array.prototype.slice.call(arguments)));\n  };\n\n  /**\n   * Make a new contextual `yllr` object. The `context` is passed to the\n   *  {@link yllr.config.setErrorType error type} constructor when a check fails.\n   * @function yllr.make\n   * @param {String} context Associated context. Cannot be empty.\n   */\n  var make = function(context) {\n    var proto;\n\n    check(context && typeof context === 'string',\n        'context: must be non-empty string');\n\n    /**\n     * Contextual yllr object. It has the same interface as the library's main\n     *  functions (with the exception of {@link yllr.make `yllr.make`}), with the\n     *  addition of an associated context to help with debugging (for instance,\n     *  to easily identify the source of the failure).\n     * @class yllr.Yllr\n     */\n    proto = {\n      /**\n       * Perform a contextual condition check.\n       * @method yllr.Yllr#check\n       * @param {*} condition Condition to check.\n       * @param {String} [message] Optional message.\n       * @see {@link yllr.check `yllr.check`}\n       */\n      check: function(condition, message) {\n        // invoke internal `__check()` with the context\n        __check.apply(this, [context].concat(Array.prototype.slice.call(arguments)));\n      }\n    };\n\n    return Object.create(proto);\n  };\n\n  /**\n   * Customizes the type of error thrown when a `check` fails.\n   * @function yllr.config.setErrorType\n   * @param {Function} [ErrorType] If specified, expected to be a constructor\n   *  function which has the same signature as the default `YllrError`. If\n   *  falsy, resets the error type to `YllrError`.\n   * @see {@link yllr.YllrError `yllr.YllrError`}\n   */\n  var setErrorType = function(ErrorType) {\n    check(!ErrorType || typeof ErrorType === 'function',\n        'ErrorType: must be falsy or function');\n\n    __ErrorType = !!ErrorType ? ErrorType : YllrError;\n  };\n\n  /**\n   * Allows enabling or disabling all checks. Subsequent calls to `yllr.check`\n   *  will cause failures if enabled, or do nothing if disabled.\n   * @function yllr.config.enableChecks\n   * @param {Boolean} [enable=true] If _truthy_ (or unspecified), checks are\n   *  enabled; otherwise, checks are disabled.\n   * @see {@link yllr.config.checksEnabled `yllr.config.checksEnabled()`}\n   */\n  var enableChecks = function(enable) {\n    __checksEnabled = enable === undefined || !!enable;\n  };\n\n  /**\n   * Determines if all checks are enabled; a compliment to `config.enableChecks()`.\n   * @function yllr.config.checksEnabled\n   * @returns {Boolean} `true` if all checks are enabled; `false` otherwise.\n   * @see {@link yllr.config.enableChecks `yllr.config.enableChecks()`}\n   */\n  var checksEnabled = function() {\n    return __checksEnabled;\n  };\n\n  /**\n   * The `yllr` library.\n   * @namespace yllr\n   */\n  return {\n    // types\n    YllrError: YllrError,\n\n    // functions\n    check: check,\n    make: make,\n\n    /**\n     * Configuration options.\n     * @namespace yllr.config\n     */\n    config: {\n      // functions\n      setErrorType: setErrorType,\n      enableChecks: enableChecks,\n      checksEnabled: checksEnabled,\n\n      // NOTE: noConflict is set by the UMD only when registering as a global\n      noConflict: undefined\n    }\n  };\n});\n"]}